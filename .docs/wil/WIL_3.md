# Weekly I Learned 3 (도메인 모델링)

## 도메인 언어를 모르면 코드를 짤 수 없다

이번 주는 **도메인 모델링**에 대해 배웠다. 그리고 실무에서 KYC(고객확인) 도메인을 딥다이브하면서 깨달았다. "코딩 실력도 중요하지만, **업무 지식이 없으면 아무것도 못 만든다**"는 걸.

## 금융 도메인의 벽

회원인증 쪽 업무를 맡았는데, 처음엔 "그냥 회원가입이랑 로그인 처리하면 되는 거 아냐?"라고 생각했다. 근데 금융권은 차원이 달랐다.

다음 용어들이 코드 곳곳에 박혀 있었다:

- **AML(Anti Money Laundering)** - 자금세탁방지
- **KYC(Know Your Customer)** - 고객확인제도
- **EDD(Enhanced Due Diligence)** - 강화된 고객확인
- **CDD(Customer Due Diligence)** - 고객 실사
- **RA(Risk Assessment)** - 위험도 평가
- **WLF(Watch List Filtering)** - 제재대상자 필터링

처음엔 영어 약자만 봐서는 무슨 뜻인지 하나도 모르겠더라. 근데 이게 단순히 용어만 아는 게 아니라, **왜 이런 절차가 필요한지**, **어떤 순서로 진행되는지**, **실패하면 어떤 조치를 해야 하는지**를 이해해야 코드를 짤 수 있었다.

## 도메인 지식이 코드로 이어지는 순간

### 1. Entity vs VO 구분

도메인을 이해하니까 자연스럽게 설계가 보이기 시작했다.

- **Customer (Entity)** - 고객은 식별 가능하고, 상태가 변한다 (미인증 → 인증 중 → 인증 완료)
- **RiskScore (VO)** - 위험도 점수는 값 자체가 중요하고, 불변이다
- **KycStatus (Enum)** - 고객확인 상태는 명확한 전이 규칙이 있다

### 2. 도메인 서비스의 필요성

"고객이 법인인지 개인인지에 따라 KYC 절차가 다르다"는 요구사항이 있었는데, 이건 Customer 엔티티 하나로는 감당이 안 됐다. 그래서 **KycDomainService**를 만들어서 여러 객체의 협력을 조율했다.

```kotlin
class KycDomainService {
    fun verifyCustomer(customer: Customer, documents: List<Document>): KycResult {
        // 개인/법인 분기
        // 서류 검증
        // 위험도 평가
        // 제재대상자 필터링
    }
}
```

## 실무에 바로 적용

이런 도메인 이해 덕분에 두 가지 큰 업무를 해낼 수 있었다:

### 1. 모든 기기 로그아웃 정책 구현

금융감독원(FIU)의 새로운 요구사항이 내려왔다. "의심 거래가 감지되면 해당 고객의 모든 세션을 강제 종료해라."

도메인 지식이 없었다면 "그냥 세션 다 지우면 되지 않나?"라고 생각했을 텐데, 실제로는:
- 어떤 케이스가 "의심 거래"인지 (RA 점수 기준)
- 어떤 고객에게 적용해야 하는지 (EDD 대상자 여부)
- 로그아웃 후 재인증은 어떻게 처리해야 하는지 (CDD 재수행 여부)

이런 걸 다 고려해야 했다.

### 2. 법인업종구분코드 추가

새로운 법 개정으로 법인고객에 대한 업종 구분 코드가 추가됐다. 이것도 단순히 "필드 하나 추가"가 아니라:
- 기존 고객은 어떻게 마이그레이션할지
- 신규 가입 시 필수 입력인지
- 업종에 따라 위험도 평가가 달라지는지

이런 업무 맥락을 이해해야만 제대로 구현할 수 있었다.

## 이번 주 배운 핵심

- **도메인 모델링**: 현실 세계의 개념을 코드로 옮기는 작업
- **Entity / VO / Domain Service**: 각각의 책임과 역할을 명확히 구분하기
- **유비쿼터스 언어**: 팀 전체가 같은 단어로 소통해야 코드도 일관성 있게 나온다
- **업무 지식이 곧 설계**: 기술만 알아서는 부족하다, 도메인을 알아야 제대로 짤 수 있다

다음 주에는 트랜잭션과 동시성 문제를 다뤄볼 예정. 고객 데이터를 다루는 만큼 정합성이 생명이니까!
