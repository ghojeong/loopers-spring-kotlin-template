# What is Popularity?

우리는 이제, 유저가 우리 서비스에서 더 좋은 상품을 탐색할 수 있도록 상품 랭킹을 제공할 거예요.

이전에는 Key-value store, Cache store 용도로 써봤던 **Redis** 의 다른 자료형, `ZSET` ( Sorted Set ) 을 활용해 볼 겁니다. **ZSET 기반**으로 시그널들을 모아 랭킹 점수를 반영하고, API 는 이 데이터를 기반으로 TOP-N API, 개별 상품 순위 정보를 제공합니다.

## Summary

지난 라운드에서 Kafka 를 통해 이벤트를 발행하고, 컨슈머가 후속 처리를 담당하도록 하여 서비스 경계를 넘어서는 확장성을 확보할 방법에 대해 학습했습니다.

이번 라운드에서는 **Redis ZSET** 을 활용해 실시간 랭킹 기능을 구현합니다. **컨슈머**는 이벤트를 소비해 ZSET 점수를 갱신하고, **API** 는 ZSET 을 조회해 랭킹 기능을 제공하도록 설계합니다.

## Keywords

- Redis Sorted Set (ZSET)
- ZINCRBY 기반 실시간 집계
- Top-N API
- 일별 Key 전략 & TTL
- 콜드 스타트 문제

## Ranking System

### **Ranking** 시스템의 특성

- 랭킹 정보가 많이 요청됨
  - **Top-N API :** 항상 유저에게 인기 있는 지면이자 다양한 큐레이션 요소로 활용
    - 홈 메인 - 인기 상품, 오늘의 Top 10, 인기순 정렬 등 
  - **개별 순위 조회 :** 특정 상품이 현재 몇 위인지 표기할 때 활용
- 주기적인 갱신이 필요함
  - 일간, 주간, 월간 단위로 새롭게 시작되는 랭킹 구조 필요 **(이번엔 일간만 진행)**
  - **콜드 스타트 문제**가 존재할 수 있음
- **RDB** 로 해결하면 안되는 걸까?
  - DB 쿼리 (`GROUP BY + ORDER BY`)  는 데이터가 쌓일수록 느려짐
  - 조회 빈도가 매우 높아 DB 과부하로 이어질 수 있음

### Redis ZSET

이전에 캐시를 위해 **Strings 자료형**을 사용해 보았다면, 이번에는 **SortedSet 자료구조**를 활용해볼 예정입니다.

- **ZSET 구조**
  - `(member, score)` 쌍을 score 기준으로 정렬된 상태로 유지함
  - **삽입/수정** : O(logN)
  - **Top-N 조회** : O(N)
- **주요 연산**
  - `ZADD key score member` : score 와 함께 member 저장 (이미 있을 경우 갱신됨)
  - `ZREVRANGE key 0 N WITHSCORES` : score 기준 Top-N 조회
  - `ZREVRANK key member` : 특정 멤버의 순위 조회
  - `ZSCORE key member` : 특정 멤버의 스코어 조회
  - `ZCARD key` : 멤버 수 조회
- **Why ZSET ?**
  - 정렬 기능이 내장되어 있어 별도 인덱스 등에 대한 설정 불필요
  - 실시간으로 랭킹 반영 가능
  - 다양한 조회 지원 : Top-N, 특정 `member` 의 순위, score 범위 검색 등
- **다른 방식과 비교**  

| 방법 | 장점 | 단점 | 적합도 |
| --- | --- | --- | --- |
| DB ORDER BY | 정합성 ↑ | 느림, 부하 ↑ | 초기/소규모 |
| 캐시(Map) + 정렬 | 간단 | 매 요청마다 정렬 필요 | 중간 |
| Redis ZSET | 빠른 정렬 내장, 다양한 조회 지원 | 메모리 사용 ↑ | 대규모 트래픽 |

### Key 설계 - 시간의 양자화💡

#### Key 설계는 왜 중요할까요?

- 랭킹은 언제부터 언제까지의 집계인지가 명확해야 의미가 있어요.
- **타임 윈도우 별로 키를 분리**하면 랭킹 데이터에 대한 리셋, 만료, 보정 등 운영을 하기 좋습니다.
- 즉, 단순 누적만 할 경우 **랭킹의 의미가 퇴색**될 수 있어요.

#### 누적만 할 경우의 문제

- 오래 전 점수를 쌓은 상품이 계속 상위에 노출됨 → 신상품은 노출될 기회가 사라짐
- 결국 **롱테일 (Long Tail) 현상** 이 나타나고, 소수 상품이 인기 상위권을 독식하게 됨
- 특정 시간 단위 집계로 **공정성을 확보**하고 신선한 정보를 노출해야 함

#### 시간의 양자화

- 집계를 일정 단위 (시간, 일, 주, 월 등) 으로 나누어서 관리
- **일간 집계** - 하루 단위로 랭킹을 관리할 수 있어야 함 → 오늘 점수와 어제 점수를 분리
- **TTL** - 메모리 관리를 위해 시간 윈도우의 1.5배~2배 정도로 잡으면 안정적

#### 예시

```java
rank:all:20250906 // 9월 6일 랭킹 집계
rank:all:20250907 // 9월 7일 랭킹 집계
```

## 가중치 합산 (Weighted Sum)

### 왜 가중치가 필요한가요?

1. 좋아요/구매/매출액은 스케일이 달라 단순 합산 시 특정 지표가 지배  
2. 서비스 전략에 따라 어떤 지표를 더 중요하게 볼지 달라짐  

#### 총점식

```java
Sum(p) = W(like)*Count(p.like) + W(order)*Count(p.order) + W(view)*Count(p.view)

* W : Weight (가중치)
* Count : 스코어를 구성하는 요소 수
```

#### 기본 가중치 예시

- **Weight(view) = 0.1**
  - 조회 수는 가장 많을 것이므로 전체 스코어를 잡아먹을 수 있음
- **Weight(like) = 0.2**
  - 좋아요 수는 주문 수보다는 **구매 결정** 관점에서 덜 중요한 지표이므로 조금 낮게 설정
- **Weight(order)** = 0.7
  - 주문 수는 유저가 구매를 결정했으므로 가장 중요한 지표라고 보고 가중치를 높게 설정

### 콜드 스타트 문제

#### 콜드 스타트?

집계 윈도우가 시작되는 시점에는 아직 점수가 쌓이지 않았을 수 있기 때문에 랭킹정보가 존재하지 않거나 대상이 부족하게 됩니다.

즉, 랭킹 정보를 위해 ZSET 을 조회했지만 **상품 목록이 없는 문제** 가 생기게 되죠. 전날 인기 있었던 상품도, 새벽에 들어온 신상품도 동일한 조건으로 시작하는 문제가 발생해요.

혹은 랭킹에 진입하지 못한 상품들은 자연스레 **클릭도 구매도 발생하지 않게 되는 악순환**으로 이어질 수도 있습니다.

#### 문제점

- 윈도우가 변경되는 시점에는 대부분 상품 점수가 0이므로 **랭킹이 의미 없어짐**
- 사용자에게는 **어제 인기 있었던 상품** 또한 랭킹에서 보길 기대할 수 있음

#### 해결

- **Score Carry-Over**
  - 새로운 키 생성 시 전날 점수의 일부를 적은 가중치를 곱해 미리 복사함
  - 이 때, 가중치는 작은 값으로 가져가 오늘의 점수가 상위로 올라가지 못하는 문제를 방지

```java
ZUNIONSTORE ranking:all:20250907 1 ranking:all:20250906 WEIGHTS 0.1 AGGREGATE SUM

`ranking:all:20250907` 로 `ranking:all:20250906` 의 스코어들에 0.1 을 곱해서 복사
```

### Before / After Score

#### Before (20250906)

```txt
product:101 → 100
product:202 → 50
```

#### After (20250907, carry-over 10%)

```txt
product:101 → 10
product:202 → 5
```

## Next Week Preview

**일간을 넘어서 주간/월간 집계를 만들려면 어떻게 하는 게 좋을까?**

이번 주차에는 **Redis ZSET 을 기반으로 랭킹 시스템을 구축**할 방법에 대해 고민해 보았습니다. 유저에게 어떻게 랭킹 시스템을 제공할 수 있을까라는 고민을 통해 **인기 있는 상품을 효율적으로 노출**할 수 있게 되었어요.

이제는 일간 집계를 활용해 주간 집계 데이터를 만들고, 월간 집계 데이터를 만들기 위해선 어떻게 해야할까 고민해볼 거예요. 차주에는 점차 많아지는 데이터나 통계들을 주기적으로 생성해내는 기능을 만들어 봅니다.
