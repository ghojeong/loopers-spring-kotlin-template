# [2주차] 설계 문서 제출 - 고정완

## 개요

이커머스 시스템의 상품, 브랜드, 좋아요, 주문 도메인에 대한 설계 문서를 작성했습니다.
요구사항 분석부터 시퀀스 다이어그램, 클래스 다이어그램, ERD까지 전체 설계 과정을 문서화했습니다.

## 작성한 문서

| 파일명 | 내용 |
| --- | --- |
| `01-requirements.md` | 도메인별 기능 요구사항 및 비기능 요구사항 명세 |
| `02-sequence-diagrams.md` | 주요 기능의 시퀀스 다이어그램 5개 (상품 조회, 좋아요 등록/취소, 주문 생성, 주문 조회) |
| `03-class-diagram.md` | 도메인 모델 및 클래스 다이어그램, 패키지 구조 제안 |
| `04-erd.md` | 데이터베이스 ERD 및 테이블 구조, 인덱스 전략 |

## 주요 설계 내용

### 1. 요구사항 정리

- 유비쿼터스 언어 정의 (User, Product, Brand, Like, Order 등)
- 도메인별 기능 요구사항 상세 작성
  - 브랜드 & 상품 조회 (필터링, 정렬, 페이징)
  - 좋아요 등록/취소 (멱등성 보장)
  - 주문 생성 (재고 차감, 포인트 차감, 외부 시스템 연동)
- 비기능 요구사항 명세 (인증, 성능, 데이터 정합성, 멱등성, 확장성)

### 2. 시퀀스 다이어그램

- 상품 목록 조회 (필터링 & 정렬)
- 상품 좋아요 등록
- 상품 좋아요 취소
- 주문 생성 (트랜잭션 범위 표현)
- 주문 상세 조회 (권한 검증 포함)

### 3. 클래스 다이어그램

- 10개 도메인 객체 설계 (User, Brand, Product, Stock, Like, Order, OrderItem, Point 등)
- Entity vs Value Object 구분 (Price, Money는 VO)
- Aggregate 설계 (Order가 OrderItem의 Aggregate Root)
- 책임 주도 설계 (도메인 로직은 도메인 객체가 처리)
- 연관 관계는 단방향 기본, 양방향 최소화

### 4. ERD 설계

- 8개 테이블 설계 (users, brands, products, stocks, likes, orders, order_items, points)
- 외래키 제약 정의 (CASCADE vs RESTRICT)
- 인덱스 전략 (조회 성능 최적화)
- 동시성 제어 (낙관적 락: version 컬럼)
- DDL 예시 포함

## 고민한 지점

### 1. 좋아요 수 집계 방식

- **문제**: 상품 조회 시 좋아요 수를 포함해야 하는데, N+1 문제가 발생할 수 있음
- **고민한 방법들**:
  - 방법 1: 상품 조회 후 각 상품마다 COUNT 쿼리 실행 (N+1 문제)
  - 방법 2: 상품 테이블에 `like_count` 컬럼 추가 (비정규화, 동기화 이슈)
  - 방법 3: JOIN 또는 서브쿼리로 한 번에 조회 (쿼리 복잡도 증가)
- **선택**:
  - 초기 구현은 방법 1로 단순하게 시작
  - 성능 이슈 발생 시 방법 3 또는 방법 2로 전환
  - 캐싱(Redis)도 고려 가능

### 2. 재고 차감 동시성 제어

- **문제**: 동시에 같은 상품을 주문하면 재고가 음수가 될 수 있음
- **고민한 방법들**:
  - 방법 1: 비관적 락 (SELECT FOR UPDATE) - 성능 저하 우려
  - 방법 2: 낙관적 락 (version 컬럼) - 충돌 시 재시도 필요
  - 방법 3: Redis 분산 락 - 추가 인프라 필요
- **선택**:
  - 낙관적 락(version 컬럼) 방식 채택
  - 충돌 빈도가 낮다면 낙관적 락이 성능상 유리
  - 재시도 로직 구현 필요 (최대 3회 등)

### 3. 주문 생성 트랜잭션 범위

- **문제**: 재고 차감, 포인트 차감, 주문 저장, 외부 시스템 연동을 어디까지 트랜잭션으로 묶을지
- **고민한 방법들**:
  - 방법 1: 모두 하나의 트랜잭션 (외부 시스템 연동 실패 시 롤백)
  - 방법 2: 외부 시스템 연동은 트랜잭션 외부 (실패 시 보상 트랜잭션)
  - 방법 3: 이벤트 기반 비동기 처리 (Saga 패턴)
- **선택**:
  - 재고 차감, 포인트 차감, 주문 저장은 트랜잭션 범위
  - 외부 시스템 연동은 트랜잭션 커밋 후 처리 (비동기 또는 Mock)
  - 외부 시스템 연동 실패 시 재시도 또는 보상 트랜잭션 구현

### 4. Price vs Money 분리

- **문제**: 금액을 표현하는 VO를 어떻게 설계할지
- **고민한 내용**:
  - Price와 Money를 분리할지, 하나로 통합할지
  - 통화(Currency)를 어떻게 관리할지
- **선택**:
  - Price: 상품 가격 전용 VO
  - Money: 더 범용적인 금액 VO (주문 총액, 포인트 등)
  - 둘 다 BigDecimal + Currency로 구성
  - 필요시 Price → Money 변환 가능

### 5. 주문 항목의 가격 저장

- **문제**: 주문 시점의 가격을 저장할지, 상품 가격을 참조할지
- **선택**:
  - 주문 시점의 가격을 `price_at_order`로 저장
  - 상품 가격이 변경되어도 주문 이력은 유지
  - 주문 내역 조회 시 정확한 금액 보장

## 리뷰 포인트

다음 부분에 대해 피드백을 부탁드립니다:

### 1. 아키텍처 관련

- [ ] Reader 인터페이스 분리가 적절한가? (읽기 전용 작업 분리)
- [ ] Service의 책임 범위가 적절한가? (도메인 로직 vs 조율 로직)
- [ ] Aggregate 설계가 올바른가? (Order ↔ OrderItem 관계)

### 2. 동시성 제어

- [ ] 낙관적 락 선택이 적절한가? 비관적 락을 고려해야 하는 경우는?
- [ ] 재시도 로직을 어떻게 구현하는 것이 좋은가?

### 3. 성능 최적화

- [ ] 좋아요 수 집계 방식에 대한 의견
- [ ] 인덱스 전략이 적절한가? 추가로 고려해야 할 인덱스는?

### 4. 예외 처리

- [ ] 비즈니스 예외와 시스템 예외를 어떻게 분리할지
- [ ] 외부 시스템 연동 실패 시 재시도 전략

### 5. 확장성

- [ ] 추후 쿠폰, 이벤트 기능 추가 시 고려해야 할 점
- [ ] 포인트/재고 이력 관리를 위한 테이블 추가 필요성

## 체크리스트

- [x] 상품/브랜드/좋아요/주문 도메인이 모두 포함되어 있는가?
- [x] 기능 요구사항이 유저 중심으로 정리되어 있는가?
- [x] 시퀀스 다이어그램에서 책임 객체가 드러나는가?
- [x] 클래스 구조가 도메인 설계를 잘 표현하고 있는가?
- [x] ERD 설계 시 데이터 정합성을 고려하여 구성하였는가?

## 추가 참고 사항

### Mermaid 다이어그램

모든 다이어그램은 Mermaid 문법으로 작성했습니다.
GitHub에서 바로 렌더링되며, 수정이 필요한 경우 쉽게 편집 가능합니다.

### 구현 순서 제안

1. 도메인 모델 구현 (Entity, VO)
2. Repository 구현
3. Service 구현 (비즈니스 로직)
4. Controller 구현 (API)
5. 테스트 작성
